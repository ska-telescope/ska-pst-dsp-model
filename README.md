## PST_PFB_inversion_verification

Compare the results of dspsr's PFB inversion implementation to the PST Signal model,
implemented in Matlab. The goal of this comparison is to assess whether the two
implementations produce the same results, within numerical precision.

Attempting to abide by the Matlab coding conventions enumerated [here](https://au.mathworks.com/matlabcentral/fileexchange/46056-matlab-style-guidelines-2-0).

### Installation

This repo uses Python to process test vectors generated by a Matlab pipeline.

With [poetry](https://poetry.eustace.io/docs/) installed:

```
cd python
poetry install
```

In order to run tests with the Matlab backend, the [Matlab runtime environment](https://au.mathworks.com/products/compiler/matlab-runtime.html)
must be installed.

### Building

With matlab installed, run `make` to create stand alone executables from
Matlab code.

### Usage

The goal of the Python code in this repo is to implement a test harness to
test different PFB inversion implementations against each other, and to the
test the temporal and spectral purity of the PFB inversion algorithm.

Testing Python and Matlab "backends" against each other:

```
[me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison]$ cd python
[me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison/python]$ poetry run python -m test.test_backends
```

Testing dspsr against some PFB inversion backend:

```
[me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison]$ cd python
[me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison/python]$ poetry run python -m test.test_matlab_dspsr_pfb_inversion
```

If these tests pass, the program will exit successfully. Moreover, it means
that the implementations being tested produce the same result to one part
in 1e-7.

We can configure these tests with the `config/test.config.json` file. For example,
if we want to turn derippling off in our tests, we change the `"deripple"`
key from `true` to `false`. See [this](#validation-configuration) for more
information on the meaning of all the fields in the `test.config.json` file.

Testing spectral and temporal purity (not currently fully implemented):

```
[me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison]$ cd python
[me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison/python]$ poetry run python -m test.test_purity
```

Testing whether PFB inversion works with dedispersion turned on:

```
[me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison]$ cd python
[me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison/python]$ poetry run python -m test.test_dedispersion
```

<!--
Generating a dual polarization complex sinuosoid:

```bash
./build/generate_test_vector complex_sinusoid 1000 0.01,0.5,0.1 single 1 config/default_header.json test_complex_sinusoid.dump ./ 1
```

Generating a dual polarization time domain impulse of width 50:

```bash
./build/generate_test_vector time_domain_impulse 1000 0.01,50 single 2 config/default_header.json test_time_domain_impulse.dump ./ 1
```

Channelizing some data:

```bash
./build/channelize ./data/test_vectors/time/o-0.010_w-1.000/time_domain_impulse.dump 8 8/7 config/OS_Prototype_FIR_8.mat test.channelized.time_domain_impulse.dump ./data/test_vectors/time/o-0.010_w-1.000/ 1
```

Synthesizing data:

```bash
./build/synthesize ./data/test_vectors/time/o-0.010_w-1.000/polyphase_analysis_alt.time_domain_impulse.dump 16384 test_synthesis.dump ./data/test_vectors/time/o-0.010_w-1.000/ 1
```


The following is a list of the files in the repo, and a brief description
of what they do.

- `single_double_fft.m`: Determines if matlab's `fft` returns an array whose data
type is the same a that of the input. This also produces a plot displaying the
numerical difference between the input arrays and the results of applying
the `fft` function to each of the input arrays. The motivation for this script
comes from the fact that Numpy's FFT implementation does not return the same
datatype for single precision inputs:

```python
>>> import numpy as np
>>> a = np.random.rand(1024, dtype=np.float32)
>>> f = np.fft.fft(a)
>>> print(f.dtype)
complex128
```

If Numpy's FFT were datatype consistent, the above example should output `complex64`.
Moreover, we can see that Numpy actually implicitly upcasts 32 bit data when
calling `numpy.fft.fft`:

```python
>>> import numpy as np
>>> a32 = np.random.rand(1024, dtype=np.float32)
>>> a64 = a32.astype(np.float64)
>>> f32 = np.fft.fft(a32) # not actually 32-bit data!
>>> f64 = np.fft.fft(a64)
>>> np.sum(np.abs(f32 - f64))
0
```

If Numpy were actually computing a 32-bit FFT, we would see some numerical
difference between `f32` and `f64` even though the inputs are attempting to
represent the same array of numbers. This is actually a known bug in Numpy:
https://github.com/numpy/numpy/issues/6012

- `write_header.m`: Writes a DADA header to an open file
- `read_header.m`: Reads a DADA header from an open file
- `load_file.m`: Create a file handler, and then pass it to a callback before
closing the file. Return whatever the callback returned.
- `save_file.m`: Create a file handler, and then pass it to a callback before
closing the file. Can pass arguments to the callback.
- `read_fir_filter_coeff.m`: Read in FIR filter coefficents from a matlab
`.mat` file.
- `struct2map.m`: Convert a `struct` object to a `containers.Map` object.
- `normalize.m`: Normalize an integer given some oversampling factor struct.
- `compare_dump_files.m`: Compare two dump files. Prefer the Python version,
as it has many more features and a cleaner interface.
- `channelize.m`: Channelize some data from a given file. Save the output.
- `synthesize.m`: Apply PFB inversion to the data in a given file. Save the
output.
- `test.m`: Run all the test commands.
- `pad_filter.m`: Zero pad the start of an FIR filter.
- `polyphase_analysis.m`: Implements polyphase filterbank algorithm.
This is originally John Bunton's code with some (small) modifications to incorporate
`os_factor` structs.
- `polyphase_analysis_alt.m`: Implements polyphase filterbank algorithm using
an alternative algorithm. This is based on code written by Ian Morrison and
Thushara Kanchana Gunaratne.
- `polyphase_synthesis.m`: Implements polyphase filterbank inversion algorithm.
- `polyphase_synthesis_alt.m`: Implements polyphase filterbank inversion algorithm.
The purpose of this function is to exactly implement the PFB inversion algorithm
used in Ian Morrison's PST spectral and temporal purity [tests](https://github.com/SKA-PST/PST_Matlab_channelizer_inverter_purity_measurement_CDR).
- `time_domain_impulse.m`: Generates a time domain impulse. Can generate
multiple impulses of varying widths.
- `complex_sinusoid.m`: Generate a complex sinusoid at a given frequency. Can
also generate a linear combination of sinusoids at any number of specified
frequencies.
- `pipeline.m`: Run the test vector generation, analysis and synthesis pipeline.
This will create a directory structure in the `data` subdirectory. -->

<!-- ### Unittesting

Run `test.m` to run a basic suite of unit-like tests. -->

### Validation Configuration

`config/test.config.json` determines what parameters are to run different
implementations of PFB inversion.

- fir_filter_coeff_file_path (str)*: Relative (to config directory) path to FIR filter coefficients, in .mat format.
- header_file_path (str): Relative (to config directory) path to default header file.
- os_factor (str): Oversampling factor, expressed as "{nu}/{de}"
- channels (int): The number of channels to generate in PFB inversion.
- input_fft_length (int): The size of the forward FFT used in PFB inversion.
- input_overlap (int): The input overlap size used in PFB inversion.
- blocks (int): Number of processing blocks to generate.
- backend: Each of the child fields can either be "python" or "matlab", indicating which implementation to use. Python is (significantly) faster, as there is no call overhead, but Matlab is the prototype "gold standard".
   - test_vectors (str): backend for generating test vectors
   - channelize (str): PFB channelizer backend
   - synthesize (str): PFB inversion backend
- n_pol (int): Number of polarizations to generate
- dm (float): Dispersion measure. Set to zero to disable dedispersion.
- period (float): pulsar period.
- dump_stage (str): Tells dspsr after which stage to dump the results of PFB inversion.
- deripple (bool): Boolean value indicating whether or not to perform derippling.
- fft_window (str): the FFT window to use in PFB inversion. Can be "no_window"
or "tukey"

*In order to get sensible results, the FIR filter coefficients must be tuned
to the oversampling factor and the number of PFB channels.
