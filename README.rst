PST_PFB_inversion_verification
==============================

These instructions describe how to compare the results of dspsr's PFB inversion implementation with the PST Signal model implemented in Matlab. The goal of this comparison is to assess whether the two implementations produce the same results, within numerical precision.

For instructions on how to quantify the performance of the Matlab implementation, please see

https://confluence.skatelescope.org/display/SE/Testing+polyphase+filter+bank+inversion+using+MATLAB+model

Installation
------------

This repo uses Python to process test vectors generated by a Matlab pipeline.

With `poetry <https://poetry.eustace.io/docs/>`_ installed:

.. code-block::

  cd python
  poetry install


In order to run tests with the Matlab backend, the `Matlab runtime environment <https://au.mathworks.com/products/compiler/matlab-runtime.html>`_
must be installed.

Building
--------

With matlab installed, run `make` to create stand alone executables from
Matlab code.

Usage
-----

Matlab
------

This repo contains Matlab code derived from the PST "Golden" signal chain model. In particular, it contains scripts for channelizing data via oversampled PFB, and performing FFT based polyphase inversion. The FFT based polyphase inversion implementation in this repo is the "Golden" implementation.

In the same way that the Python code in this repo implements a harness to test the purity of the DSPSR PFB inversion implementation, there is a Matlab script ``current_performance.m`` that implements a pipeline for determining the temporal and spectral purity of the "Golden" PST PFB inversion algorithm.


Polyphase Filterbank Filter Generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Two approaches to generating Polyphase Filterbank (PFB) filter coefficients have been developed for the SKA. *These two approaches require two different PFB channelizers*. Two separate Matlab scripts encapsulate these two approaches:

- ``design_PFB_FIR_filter.m``: Uses a single stage FIR filter design. This is the script used to develop SKA Low channelizer coefficients. Requires using the PFB implementation in ``polyphase_analysis.m``

- ``design_PFB_FIR_filter_two_stage.m``: Uses a two stage FIR filter design. This is adapted from the script used to develop SKA Mid channelizer coefficients. Requires using the PFB implementation in ``polyphase_analysis_padded.m``. The two stage design allows for generating large (>1e5) numbers of coefficients.


Polyphase Filterbank Channelizer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Matlab code in this repo has two different PFB channelizers.

- ``polyphase_analysis.m``: To be used with SKA Low coefficients, or those created by ``design_PFB_FIR_filter.m``. This is derived from code originally put together by John Bunton. This does not zero pad the input data, meaning that the number of output samples is less than (input samples) / (channels * oversampling ratio).
- ``polyphase_analysis_padded.m``: To be used with SKA Mid coefficients, or those created by ``design_PFB_FIR_filter_two_stage.m``. This is derived from code orignally put together by Thushara Gunaratne. This zero pads the input data.


Polyphase Filterbank Inversion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- polyphase_synthesis.m: This is the Golden FFT based PFB inversion implementation; this is the implementation against which others' correctness is judged.


Python
------

The goal of the Python code in this repo is to implement a test harness to test different PFB inversion implementations against each other, and to the test the temporal and spectral purity of the PFB inversion algorithm.


Testing Python and Matlab "backends"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``test_backends.py`` script compares the output of the Matlab and Python PFB channelizers.

.. code-block::

  [me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison]$ cd python
  [me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison/python]$ poetry run python -m verify.test_backends


Testing dspsr and Matlab PFB Inversion implementations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block::

  [me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison]$ cd python
  [me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison/python]$ poetry run python -m verify.test_matlab_dspsr_pfb_inversion

Full command line arguments:

.. code-block::

  usage: test_matlab_dspsr_pfb_inversion.py [-h] [-t] [-f] [-n N_TEST]
                                          [-c SUB_CONFIG_NAME] [--save-output]
                                          [--extra-args EXTRA_ARGS] [-v] [-s]

  Test DSPSR and Matlab PFB Inversion Implementations

  optional arguments:
    -h, --help            show this help message and exit
    -t, --do-time
    -f, --do-freq
    -n N_TEST, --n-test N_TEST
                          Specify the number of test vectors to use
    -c SUB_CONFIG_NAME, --config SUB_CONFIG_NAME
                          Specify which sub configuration to use
    --save-output         Indicate whether to save intermediate products
    --extra-args EXTRA_ARGS
                          Specify any additional arguments to pass to dspsr
    -v, --verbose
    -s, --do-simulated-pulsar


If these tests pass, the program will exit successfully. Moreover, it means that the implementations being tested produce the same result to one part in 1e-6.

We can configure these tests with the `config/test.config.json` file. For example, if we want to turn derippling off in our tests, we change the ``"deripple"`` key from ``true`` to ``false``. See `Validation Configuration`_ for more information on the meaning of all the fields in the ``test.config.json`` file.

Testing spectral and temporal purity
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block::

  [me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison]$ cd python
  [me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison/python]$ poetry run python -m verify.test_purity

This code uses the ``"test"`` configuration from ``config/test.config.json`` by default. We can tell the script to do only temporal or spectral purity tests with the ``-t`` and ``-f`` flags respectively.

Full command line arguments:

.. code-block::

  [me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison]$ cd python
  [me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison/python]$ poetry run python -m verify.test_purity -h

  usage: purity.py [-h] [-t] [-f] [-n N_TEST] [-c SUB_CONFIG_NAME]
                   [--save-output] [--extra-args EXTRA_ARGS] [-v]

  DSPSR PFB inversion purity

  optional arguments:
    -h, --help            show this help message and exit
    -t, --do-time
    -f, --do-freq
    -n N_TEST, --n-test N_TEST
                          Specify the number of test vectors to use
    -c SUB_CONFIG_NAME, --config SUB_CONFIG_NAME
                          Specify which sub configuration to use
    --save-output         Indicate whether to save intermediate products
    --extra-args EXTRA_ARGS
                          Specify any additional arguments to pass to dspsr
    -v, --verbose


The ``test_purity.py`` script creates a JSON output file in the ``products`` subdirectory. The name of this file depends on the configuration parameters specified in ``test.config.json``. We can plot the results:

.. code-block::

  [me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison]$ cd python
  [me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison/python]$ poetry run python -m plot_purity_results.py -i ./../products/report.\*.json


Testing whether PFB inversion works with dedispersion turned on
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block::

  [me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison]$ cd python
  [me@host path/to/PST_Matlab_dspsr_PFB_inversion_comparison/python]$ poetry run python -m test.test_dedispersion



..
..
.. The following is a list of the files in the repo, and a brief description
.. of what they do.
..
.. - `single_double_fft.m`: Determines if matlab's `fft` returns an array whose data
.. type is the same a that of the input. This also produces a plot displaying the
.. numerical difference between the input arrays and the results of applying
.. the `fft` function to each of the input arrays. The motivation for this script
.. comes from the fact that Numpy's FFT implementation does not return the same
.. datatype for single precision inputs:
..
.. ```python
.. >>> import numpy as np
.. >>> a = np.random.rand(1024, dtype=np.float32)
.. >>> f = np.fft.fft(a)
.. >>> print(f.dtype)
.. complex128
.. ```
..
.. If Numpy's FFT were datatype consistent, the above example should output `complex64`.
.. Moreover, we can see that Numpy actually implicitly upcasts 32 bit data when
.. calling `numpy.fft.fft`:
..
.. ```python
.. >>> import numpy as np
.. >>> a32 = np.random.rand(1024, dtype=np.float32)
.. >>> a64 = a32.astype(np.float64)
.. >>> f32 = np.fft.fft(a32) # not actually 32-bit data!
.. >>> f64 = np.fft.fft(a64)
.. >>> np.sum(np.abs(f32 - f64))
.. 0
.. ```
..
.. If Numpy were actually computing a 32-bit FFT, we would see some numerical
.. difference between `f32` and `f64` even though the inputs are attempting to
.. represent the same array of numbers. This is actually a known bug in Numpy:
.. https://github.com/numpy/numpy/issues/6012
..
.. - `write_header.m`: Writes a DADA header to an open file
.. - `read_header.m`: Reads a DADA header from an open file
.. - `load_file.m`: Create a file handler, and then pass it to a callback before
.. closing the file. Return whatever the callback returned.
.. - `save_file.m`: Create a file handler, and then pass it to a callback before
.. closing the file. Can pass arguments to the callback.
.. - `read_fir_filter_coeff.m`: Read in FIR filter coefficents from a matlab
.. `.mat` file.
.. - `struct2map.m`: Convert a `struct` object to a `containers.Map` object.
.. - `normalize.m`: Normalize an integer given some oversampling factor struct.
.. - `compare_dump_files.m`: Compare two dump files. Prefer the Python version,
.. as it has many more features and a cleaner interface.
.. - `channelize.m`: Channelize some data from a given file. Save the output.
.. - `synthesize.m`: Apply PFB inversion to the data in a given file. Save the
.. output.
.. - `test.m`: Run all the test commands.
.. - `pad_filter.m`: Zero pad the start of an FIR filter.
.. - `polyphase_analysis.m`: Implements polyphase filterbank algorithm.
.. This is originally John Bunton's code with some (small) modifications to incorporate
.. `os_factor` structs.
.. - `polyphase_analysis_alt.m`: Implements polyphase filterbank algorithm using
.. an alternative algorithm. This is based on code written by Ian Morrison and
.. Thushara Kanchana Gunaratne.
.. - `polyphase_synthesis.m`: Implements polyphase filterbank inversion algorithm.
.. - `polyphase_synthesis_alt.m`: Implements polyphase filterbank inversion algorithm.
.. The purpose of this function is to exactly implement the PFB inversion algorithm
.. used in Ian Morrison's PST spectral and temporal purity [tests](https://github.com/SKA-PST/PST_Matlab_channelizer_inverter_purity_measurement_CDR).
.. - `time_domain_impulse.m`: Generates a time domain impulse. Can generate
.. multiple impulses of varying widths.
.. - `complex_sinusoid.m`: Generate a complex sinusoid at a given frequency. Can
.. also generate a linear combination of sinusoids at any number of specified
.. frequencies.
.. - `pipeline.m`: Run the test vector generation, analysis and synthesis pipeline.
.. This will create a directory structure in the `data` subdirectory. -->
..
.. <!-- ### Unittesting
..
.. Run `test.m` to run a basic suite of unit-like tests. -->

Validation Configuration
------------------------

``config/test.config.json`` determines what parameters are to run different
implementations of PFB inversion.

- fir_filter_coeff_file_path (str): Relative (to config directory) path to FIR filter coefficients, in .mat format.
- header_file_path (str): Relative (to config directory) path to default header file.
- os_factor (str): Oversampling factor, expressed as "{nu}/{de}"
- channels (int): The number of channels to generate in PFB inversion.
- input_fft_length (int): The size of the forward FFT used in PFB inversion.
- input_overlap (int): The input overlap size used in PFB inversion.
- blocks (int): Number of processing blocks to generate.
- backend: Each of the child fields can either be "python" or "matlab", indicating which implementation to use. Python is (significantly) faster, as there is no call overhead, but Matlab is the prototype "gold standard".
   - test_vectors (str): backend for generating test vectors
   - channelize (str): PFB channelizer backend
   - synthesize (str): PFB inversion backend
- n_pol (int): Number of polarizations to generate
- dm (float): Dispersion measure. Set to zero to disable dedispersion.
- period (float): pulsar period.
- dump_stage (str): Tells dspsr after which stage to dump the results of PFB inversion.
- deripple (bool): Boolean value indicating whether or not to perform derippling.
- fft_window (str): the FFT window to use in PFB inversion. Can be "no_window"
or "tukey"

In order to get sensible results, the FIR filter coefficients must be tuned
to the oversampling factor and the number of PFB channels.
